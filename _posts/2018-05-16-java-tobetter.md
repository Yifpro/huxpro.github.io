---
layout:       post
title:        "java 优化"
subtitle:     "java-tobetter"
date:         2018-05-16 12:00:00
author:       "Yifpro"
header-img:   "img/in-post/post-eleme-pwa/eleme-at-io.jpg"
header-mask:  0.3
catalog:      true
multilingual: true
tags:
    - 前端开发
    - JavaScript
    - PWA
---

#### 一、采用Clone() 方式创建对象

在java.lang.Object 中有一个clone()方法，它返回的是一个新的对象。和 'new' 关键字返回的对象不同，这个新对象会包含一些原来对象的信息，不是对象的初始信息。一个对象实现Cloneable接口，通过调用clone()方法拷贝出一个新对象，这个过程不会调用任何的构造函数。

## 二、减少对boolean判断

1. 代码执行更快
2. 代码变得简洁

<!--more-->

```java
//对boolean 判断
boolean test(String str){
    return str.startsWith("A")==true;
}

//
boolean test(String str){
    return str.startsWith("A")
}
```

## 三、多用条件操作符(  "?  ")

1. 条件操作符更加简洁

~~~java
//if else 方式
int test (boolean flag){
    if(flag){
    	return 0;
	}else{
        return 1;
	}
}
//操作符方式
int testT(boolean flag){
    return flag?0:1;
}
~~~

## 四、静态方法代替实例方法

区别

1. 外部调用静态方法，无需创建对象，可以使用"类名.方法名"，也可以使用"对象名.方法名"；而实例方法只能通过"对象名.方法名"方式
2. 静态方法只允许访问本类静态成员(静态成员变量和静态方法)，实例方法无限制

注：如果不需要访问对象外部，可以将方法声明为静态方法。因为为了实现对多态的支持，实例方法需要维护一张类似虚拟函数导向表的结构，所以需要消耗更多的资源

## 五、多使用局部函数变量

1. 局部变量 ：方法传递的参数和调用时创建的变量

2. 成员变量

   - 静态变量（类变量）：①被static 关键字修饰  ② 被所有对象共享（某一个对象修改它，所有对象都是修改后结果） ③ 只要程序加载类的字节码，不用创建任何实例，静态变量就会被分配空间  ④ 可以直接类名来引用
   - 实例变量：① 没有被static 关键字修饰  ② 属于对象私有（某一个对象将其改变，不会影响其他对象）③ 必须创建实例对象，实例变量才能被使用

   方法传递的参数和调用时创建的变量（局部）都保存在栈中读写速度较快；其他变量（成员）(静态变量、实例变量)在堆中创建，并保留下来

## 六、 用一维数组代替二维数组

​	二维数组的访问速度优于一维数组，但，二维数组占用更多的内存空间（约为一维数组的10倍）

## 七、对象的创建和访问过程

  1. 虚拟机遇到"new"指令是，首先检查此指令的参数是否能在常量池中找到类的符号引用，并检查此符号引用代表的类是否被加载，解析和初始化，若没有则执行类加载的过程

2. 类加载检查后，虚拟机会给新生对象分配内存，分配内存有两种方式（由垃圾收集器是否带有压缩整理功能决定）

     ​	a、指针碰撞：如果堆中内存是规整的（用过的和空闲的各放一边），分界点放着指示器（一个指针）分配内存就是把指针向空闲空间的一边移对象大小相等的距离。

     ​	b、空闲列表：如果堆中内存不是规整的，虚拟机需要维护一张记录那块内存可用的表，分配时就从列表中找到一块足够大的空间分配给实例对象，并更新列表记录.

     

3. 对象创建的线程安全，解决方案

     ​	a、对分配内存空间的动作进行同步

     ​	b、把分配内存操作按线程划分不同空间之中进行，即给每个线程在堆中预先分配一块小内存，那个线程要创建对象，就在那个线程的TAB上分配，线程内存满时，新的TABE才同步锁定  

     

4. 内存分配完成后，虚拟机需要将内存出生后喂零值；然后对对象进行必要设置（如：类的元数据）

5. 最后，需要执行init() 方法，把对象安卓程序员意愿进行初始化

##  八、对象内存布局

对象分为三部分

1. 对象头：①、对象运行时数据/Mark Word（哈希码，GC[^ 1]分代年龄、线程持有的锁等） ②、类型指针（指向元数据的指针），通过这个指针确定此对象是哪个类德实例
2. 实例数据:程序代码中定义的各种类型的字段内容
3. 对齐填充：不是必然，起到占位符作用。HotPot VM要求对象起始地址必须为8字节，对象头为8字节，实例数据可能不是8字节，对齐填充用来对齐实例数据没有对齐的办法

## 九、对象访问定位

java通过栈中的reference数据操作堆中的具体对象，访问方式有两种

​    1.句柄：堆会划分一块内存作为句柄池，引用里存储着句柄地址，句柄中包含对象实例数据和类型数据的具体地址信息

​    2.直接指针：引用存储的是对象地址

![](java-优化\直接.png)



## 十、集和内避免返回null

​	在返回数组或集和方法中，如果需要返回空数据，尽量不要返回null，而是返回大小为零的数组或集和，这样，在判断方法返回值时就不会报NullPointerException异常

## 十一、ArrayList、LinkedList和Vector比较

相同：它们均实现AbstractList，AbstractList扩展自AbstractCollection，并直接实现List接口AbstractList最大限度减少了"随即访问"随即存储（如：数组）支持的接口的工作。对于连续的访问随即（如链表），应优先使用AbstractSequentiaList，此接口最大限度减少"连续访问"数据存储接口的工作

1. ArrayList和Vector使用数组原理实现，区别在于，ArrayList线程不安全，Vector中绝大部分方法做了线程同步，所以线程安全；LinkedList使用循环双向链表数据结构，由一系列链表项[^ 2]连接而成
2. ArrayList容量需求超过当前数组预定义的最大值，需要调用System.arraycopy()方法进行大量的数组复制操作；LinkList使用链表结构，不需要维护容量大小，每次新增元素都要创建一个新的Entry对象，并进行赋值操作。容易对性能产生影响
3. ArrayList基于数组实现，而数组是一块连续的内存空间，所以总是在尾端增加数据，如果在任意位置插入数据，需要该位置之后的元素重新排列，所以效率较差，LinkedList基于链表数据结构，因此插入数据不会导致性能下降
4. ArrayList允许插入所有元素包括null，可以根据索引开始随机访问，缺点是指定索引位置插入对象或删除对象速度较慢，删除元素越靠前，数组重组开销越大，速度也就也慢
5. LinkedList 获取元素时会随着索引的变大，程序速度就也慢，因为它只能从开始遍历直到索引处

## 十二、Vector和HashTable比较

1. Vector 实现了一个动态增长数组，给每个元素分配整数索引号；可以在创建以后根据实际元素个数增加和减少。当元素被添加到向量中，向量存储长度的增加是以增长幅度因素指定的。所以，容量因素的值总是大于向量的长度。为了避免增加多余存储空间，可以先根据需要增加适量向量容量
2. Hash实现一个哈希表，根据键映射相应的值，键和值都可以为null，且键的对象编写实现hashCode和equals方法，初始容量（哈希表创建时容量）和加载因子影响其性能
3. 不推荐使用HashTable、Vector，因为他们的同步机制降低了性能，在多线程情况下使用列表或HashMap，可以利用Collections为我们提供的synchronizedList(List list)或synchronizedMap(Map map)方法，它返回一个线程安全的同步列表或同步的HashMap
4. HashMap实质上是一个链表数组，它是无序的

## 十三、 LinkedHashMap 和TreeMap

1. LinkedHashMap继承HashMap，在HashMap基础上增加一个链表，以存放元素顺序，性能整体较快。基于元素进入集和顺序或被访问的先后顺序排序
2. TreeMap实现了SortedMap接口，因此可以对元素进行排序，基于元素固有顺序

## 十四、字符切割

1. 使用Split方式切割字符时性能较差，可以使用正则表达式或StringTokenizer处理字符串

   ~~~java
   	StringTokenizer st = new StringTokenizer(str, ",");
   		while (st.hasMoreElements()) {
   			System.out.println(st.nextToken());
   		}
   ~~~

## 十五、String、StringBuffer 和StringBuilder 区别

1. String类使用"final"修饰的字符数组保存字符串（private final char value[];），所以String对象不可变（即每次对String对象的修改都会产生新的对象）。对字符串修改时（如：字符串拼接，替换），String对象都会产生新的对象，所以性能较差
2. StringBuffer/StringBuilder 每次都是对自身进行操作，它们区别在于StringBuffer是线程安全（因为需要保证同步，效率比StringBuilder慢），StringBuilder线程不安全

## 十六、引用级别

1. 强引用（FinalReference）:强引用不会被JVM清理，平时声明的就是强引用（java 默认引用类型）

   特点

   - 可以直接访问目标对象
   - 指向的对象任何时候都不会被系统回收，即使抛出OOM[^3]
   - 可能导致内存泄漏  

     

2. 软引用（SoftReference）:通过一个软引用声明，JWM抛出OOM之前，会清理所有的软引用对象；当垃圾回收器决定回收软引用时，会清理软引用，并把引用存放到引用队列

3. 弱引用（WeakReference）:通过软引用声明，JVM会尽量让软引用存活更久，迫不得已才清理

4. 虚引用（PhantomReference）:通过虚引用声明，，每次垃圾回收时都会被回收，所以获取虚引用里的对象是总是为空s

## 十七、垃圾回收算法

1. 引用次数器 ：当有新的引用指向某个对象时把计数器的值加1，当某个引用失效时，计数器减1；
2. 跟踪对象引用



[^ 1]: (Garbage Collection,垃圾收集,垃圾回收 )
[^ 2]: 链表项由元素内容、前驱表项、后驱表项组成
[^3]: Out Of Memory(内存溢出)
